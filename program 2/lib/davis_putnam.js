// Generated by CoffeeScript 1.9.0
(function() {
  var dp;

  Array.prototype.clone = function() {
    return this.slice(0);
  };

  dp = function(atoms) {
    var v, del, dp1, obvious_assign, propagate, pure_literals, x;
    var foundAtoms = [];

    atoms = atoms.map( function(el){
      return el.split(' ');
    });

    get_pure_literals = function (atoms){
      var i,j,el,key;
      var pl = {};
      var literals = [];

      // loop through the 2d array   
      for(i in atoms){
        for (j in atoms[i]){

          // get a pointer to the 2nd dimension
          el = atoms[i][j];


          // get the character w/o the sign
          key = Math.abs(el);
          
          // if this is the first time we've seen this atom
          if(!(key in pl)){
            pl[key]={};
          }

          // we want to put negs/false in the 0th position ; pos/true in the 1st position
          // we'll put the original el value as the value at that position (bonus, free space!)
          // later, any obj (pl[key]) with length 1 will be considered a pure literal
          //
          // note, this could have been done with an array, saving the extra loop down below,
          // but doing so incurs extra overhead for removing the null item from the 
          // array if the literal was positive (inserted at pos 1). 
          //
          // use a ternary here to determine the el's sign
          // ~A = 0 ; A = 1
          
          pl[key][ (el>0)?1:0 ] = el;
        }
      } 

      // now that we have the table filled out, 
      // let's return only those that we've seen as only one polarity
      for(i in pl){

        // any object with size 1 is our literal
        if(Object.keys(pl[i]).length === 1){

          // we don't know if the key here is 1 or 0, so the
          // easiest way to get the value of the first item w/o knowing the key name
          // is to loop and grab the val
          for(j in pl[i]){
            literals.push(pl[i][j]);
            continue;
          }
        }
      }

      return literals;
    };

    function removeClauses_Literals(set, literals){

        // we'll always have a nested array
        // if any literal matches an atom, remove the clause from the set
        // (return false for every match)
      return set.filter( function(el){ 
        return !el.some(function(el){
          return literals.some(function(l){
            return el === l 
          });
        }); 
      });
    }

    function hasSingletons(set){
      return set.some(function(clause){
        return clause.length === 1;
      });
    }

/*Array.prototype.intersect = function() {
  return this.filter(function(v) {
    return [x].every(function(a) {
        return a.indexOf(v) !== -1;
    });
  });
};*/



    function _removeLiterals(set, literals){
      // literals is an array of literals
      var accumulator = [];
      var temp;

      set.forEach(function(el){
        
        // we'll always have a nested array
        // if any literal matches the atom, remove it from the set
        // (return false for every match)
        temp = el.filter( function(e){
          return !literals.some(function(atom){
            return (atom === e);
          }); 
        });
        // only add it to the new set if it has a length
        // this also prunes empty nodes
        if(temp.length){
          accumulator.push(temp);
        }
      });
      return accumulator;
    }

    function dp1(atoms, s, v) {
      var a,literals,singletons;
          // take the incoming string disjunctions, convert them to a 2d array

          keepLooping = true;
      // Loop as long as there are easy cases to cherry pick */
      while (keepLooping) {       
        /*  BASE OF THE RECURSION: SUCCESS OR FAILURE */
        // Success: All clauses are satisfied
        if(typeof s != "undefined" && s != null && s.length == 0){
          for(a in atoms){
            //if V[A] == UNBOUND then assign V[A] either TRUE or FALSE;
          }
          return v;

        }
        else if (false/*some clause in S is empty */ ){
          //nil
          return;

        }


        singletons = [];
        /* EASY CASES: PURE LITERAL ELIMINATION AND FORCED ASSIGNMENT */  
        literals = get_pure_literals(s);

        if( literals.length ){
          v = obvious_assign(literals,v);
          s = removeClauses_Literals(s, literals);
        }else if(hasSingletons(s)){
          v = obvious_assign(singletons,v);
          s = removeClauses_Literals(s, literals);
        }else{
          keepLooping = false;
        }


        
/* EASY CASES: PURE LITERAL ELIMINATION AND FORCED ASSIGNMENT */
    else if (there exists a literal L in S /* Pure literal elimination */
               such that the negation of L does not appear in S)
          then { V := obvious_assign(L,V);
                 delete every clause containing L from S;
               }
    else if (there exists a clause C in S       /* Forced assignment */
                containing a single literal L)
           then { V := obvious_assign(L,V)
                  S := propagate(atom(L), S, V);
                }
    else exitloop;  /* No easy cases found */
  }   /* endloop */
      
      return s;
    };



    dp1(s,v);

    
    
    // Propagate 
    this.propagate = function(a, s, v) {
      for(var c in s){
        if((a in c) && v[a]===true) || (!a in c) && v[a] === false){
          delete s[c];
        }
      }
      return s;
    };

    obvious_assign = function(literals, v) {
      for(var l in literals){
        // if l>0, it's true, else false
        v[l] = l > 0;
      }
      return v;
    };
  };

}).call(this);
