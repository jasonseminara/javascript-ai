// Generated by CoffeeScript 1.9.0
(function() {
  var dp;

  Array.prototype.clone = function() {
    return this.slice(0);
  };



  dp = function(atoms) {
    var atom, v, dp1, obvious_assign, propagate, get_pure_literals, hasSingletons, pickNextAtom;
    var foundAtoms = [];

    atoms = atoms.map( function(el){
      return el.split(' ');
    });

    atom = function (a){
      return Math.abs(a);
    }

    hasSingletons = function(set){
      return set.some(function(clause){
        return clause.length === 1;
      });
    };


    get_pure_literals = function (atoms){
      var pl = {};
      var literals = [];

      // we want to put negs/false in the 0th position ; pos/true in the 1st position
      // we'll put the original el value as the value at that position (bonus, free space!)
      // later, any obj (pl[key]) with length 1 will be considered a pure literal
      //
      // note, this could have been done with an array, saving the extra loop down below,
      // but doing so incurs extra overhead for removing the null item from the 
      // array if the literal was positive (inserted at pos 1). 
      //

      atoms.map(function(clause){
        clause.map(function(el){
          // get the character w/o the sign
          var key = atom(el);

          // if this is the first time we've seen this atom
          if(!(key in pl)){
            pl[key]={};
          }

          // use a ternary here to determine the el's sign
          // ~A = 0 ; A = 1
          pl[key][ (el>0)?1:0 ] = el;
        });
      });


      // now that we have the table filled out, 
      // let's return only those that we've seen as only one polarity
      for(i in pl){

        // any object with size 1 is our literal
        if(Object.keys(pl[i]).length === 1){

          // we don't know if the key here is 1 or 0, so the
          // easiest way to get the value of the first item w/o knowing the key name
          // is to loop and grab the val
          for(j in pl[i]){
            literals.push(pl[i][j]);
            continue;
          }
        }
      }

      return literals;
    };


    /**
    * Remove Clauses containing Literals
    */
    removeClauses_Literals = function (set, literals){
      // we'll use filter here to remove the anything that has a clause containing a literal
      return set.filter( function(e){ 
        return !e.some( function(el){
          return literals.some( function(l){
            return el === l 
          });
        }); 
      });
    }
    obvious_assign = function(l, v) {
      // if l>0, it's true, else false
      v[atom(l)] = l > 0;
      return v;
    };  

    pickNextAtom = function(s,v) {
      for(var i in s){
        for(var j in s[i]){
          if( !(atom(s[i][j]) in v) ){
            return s[i][j];
          }
        }
      }
    };

    propagate = function(a, s, v) {
      
      return s.filter(function(c, i, arr){

        // if ((A in C and V[A]=TRUE) or (~A in C and V[A]==FALSE))
        // then delete C from S
        return !((c.indexOf(a)  > -1) && (v[a]===true) || (c.indexOf(-a) > -1) && (v[a] === false));

      }).map( function(c){

        // if(A in C and V[A]==FALSE) then delete A from C
        // if (~A in C and V[A]==TRUE) then delete ~A from C;
        return c.filter( function(el){
          if (!((el === a && v[a]==false) || (-(el) === a && v[a]==true))){

            console.log("keeping " ,el ," in ", c);
          }else{
            console.log("removing " ,el ," from ", c);
          }
          return !((el === a && v[a]==false) || (-(el) === a && v[a]==true));
        });
      });
    };


    dp1 = function (atoms, s, v) {
      var a,literals,singletons,keepLooping;
          // take the incoming string disjunctions, convert them to a 2d array

      keepLooping = true;
      // Loop as long as there are easy cases to cherry pick */
      while (keepLooping) {       
        /*  BASE OF THE RECURSION: SUCCESS OR FAILURE */
        // Success: All clauses are satisfied
        if(typeof s != "undefined" && s != null && s.length == 0){
          for(a in atoms){
            //if V[A] == UNBOUND then assign V[A] either TRUE or FALSE;
          }
          return v;

        }
        else if (false/*some clause in S is empty */ ){
          //nil
          return;

        }


        singletons = [];
        /* EASY CASES: PURE LITERAL ELIMINATION AND FORCED ASSIGNMENT */  
        literals = get_pure_literals(s);

        /* Pure literal elimination */
        if( literals.length ){
          v = obvious_assign(literals,v);
          s = removeClauses_Literals(s, literals);

        /* Forced assignment */
        }else if(hasSingletons(s)){
          v = obvious_assign(singletons,v);
          s = removeClauses_Literals(s, literals);
        
         /* No easy cases found */
        }else{
          keepLooping = false;
        }
      }

      var a = pickNextAtom(s,v);
      v[a]=true;
      var s1 = propagate(a,s,v);

/* PICK SOME ATOM AND TRY EACH ASSIGNMENT IN TURN */
pick atom A such that V[A] == UNBOUND;  /* Try one assignment */
V[A] := TRUE;
S1 := propagate(A, S, V);
VNEW := dp1(ATOMS,S1,V);
if (VNEW != NIL) then return(VNEW);

/* IF V[A] := TRUE didn't work, try V[A} := FALSE; */
V[A] := FALSE;
S1 := propagate(A, S, V);
return(dp1(ATOMS,S1,V));
      
      return s;
    };


/////////////////


    dp1(s,v);


  };

}).call(this);
